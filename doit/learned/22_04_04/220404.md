# [The Art of Computer Programming](../../README.md)
---

## Goal : 알고리즘 작성에 앞서 미리 알고가야할 중요 내용을 정리하자.

---

## Debug & Testing
* Debuging 
  * 작은 입력에 대해 제대로 실행되는지 확인하자. 
  * 단정문(assertion)사용, 조건이 거짓일 때 오류 반환 이후 프로그램 강제 종료.
  * 프로그램의 계산 중간 결과 출력. 

* Testing 
  * 디버깅을 마친 뒤 문제를 제출 전 여러 테스트로 검증을 하자. 
  * 하지만 알고리즘 문제는 문제 해결 속도 또한 중요하기 때문에, 어느정도 테스팅을 해야하는지 문제를 많이 풀어보며 감을 익히자. 

---

## Reconize Variable Range

1. 산술 오버플로
   1. 너무 큰 결과 -> 변수 형태에 주의하자!
   2. 너무 큰 중간 값 -> ***처리 과정 중간*** 에 큰 값을 처리해야 하는 경우, 값의 최대 범위를 고려하자!
   3. 너무 큰 ***'무한대'***값, 무한대 값의 연산에 주의하자 -> 보통 최대값이 필요한 경우 임의의 무한대 값을 사용하는데 그때 주의해서 봐야할 것같다. 
   
2. 오버플로를 피하는 방법
   1. 더 큰 자료형 선택 -> ex) int => long long
   2. 연산 순서 재배치 -> 값이 같은 점화식의 경우, 연산 순서를 재배치의 연산 과정 중 변수의 오버플로를 막을 수 있다!(사칙 연산에 특히 유용할 듯 하다.)

3. 자료형의 프로모션(promotion of type)
   1. 컴파일러의 자동 형변환(연산 시 자동으로 실행됨.) -> 특히 양의 정수 형태의 자료형 과정에서 연산 과정 중 문제가 생기는 경우가 많다. 
   2. 특히 size_t, unsigned int => 어지간 하면, int로 사용하자. -> 우선 풀고 나중에 최적화 하는 과정에서 하나씩 검증해가며 알고리즘을 작성하는 것이 옳은 것같다. 

4. 실수 자료형
   1. 컴퓨터에서 실수 자료형 표현시 사용되는 근사값으로 부터 파생되는 문제. -> 이거 조금 많이 복잡함.
   2. 흠.. 실수 표현 방식에 대한 기본적인 지식을 알아두고, 그 장단점을 먼저 알아보자.
   3. 먼저 IEEE 754 표준에 대해 알고가자.
      1. 2진수로 실수 표기
      2. 부동 소수점 표기법
      3. 무한대, 비정규 수 등의 특수한 값이 존재한다. 
   
---
* 아무리 생각해도 실수에 대한 내용은 따로 Chapter를 빼서 추가설명이 필요할 것 같아 보충 기록을 한다.

>가장먼저 부동 소수점 표기해 대해 알아보자.
>> 1. 부동 소수점은 정수부와 소수부로 구분된다. 
>>> 이렇게 하는 이유는 소수점을 옮길 수 있어 정수부에 최적화된 비트 사용후 남은 비트를 소수부에 할당할 수 있어, 저장할 수 있는 데이터의 양이 많아진다는 장점이 있다. 
> 2. 실수형 변수에 할당되는 정보는 . 
> > 1. 부호 비트(sing bit): 양수와, 음수를 구분하는 정보를 나타낸다.
> > 2. 지수(exponent): 소수점을 몇 칸 옮겼는지에 대한 정보를 나타낸다.
> > 3. 가수(mantissa): 소수점을 옮긴 실수의 최상위 X비트.

라고 했을때...

1. 부호비트 -> 1비트 할당. 
2. 남은 비트 지수와 가수부에 할당.

* 이때! (중요) -> 남은 지수와 가수에 할당하는 비트 수에 따라 실수형이 표현할 수 있는 숫자의 크기와 정확도가 결정된다. 
  * 지수보다 가수부에 비트가 많이 할당될 수록 정확도가 올라감. 
  * 이유 => 유리수를 표현하는데, 더 정확한 근사치를 표현할 수 있기 때문, (아 물론, 정확한 실수표현을 할 수 있는 유리수가 물론 존재하지만 이는 논외로 하겠다.)
* 따라서!
* 컴파일러는 자동으로 지수부보다 가수부에 더 많은 비트를 할당한다.
  * 이유 => 지수는 소수점을 움직인 횟수이기 때문에 지수가 상대적으로 작더라도 실생활에서 사용하는 거의 대부분의 수를 표현 가능하기 때문이다. 
  * 생각해보자. 소수점 아래 0이 2^10 -1(1023)이상 찍힌 경우는 일상생활에서 자주 사용되지 않는다. 인정?

위에서 알 수 있는 결론, 가수부에 더 많은 비트가 할당되며, 때문에 float 쓰지말고 어지간하면 double형 쓰자. 

### 2진수에 대한 기초적인 내용과, 보수 표현에 대해서는 생략했다.

---

### 자 이제 실수형 예기를 마저 하자면,

* 실수형 비교연산
   * 두 실수 값이 같은지 확인할 때 => 어느정도의 오차를 염두해 두어야 한다.
   * 오차범위 설정 예시. 
``` cpp
bool absoluteFqual(double a, dobule b){
   return fabs(a-b) < 1e-10;  
  // 임의로 지정한 오차범위 내에 들어온다면,같은 값으로 인정
}
```
* 이때 주의할 점은, 비교할 실수의 크기들에 비례해 오차 한도를 작성자 임의로 정해두어야 한다.
   * 실수형 비교연산에 있어 오차 한도를 설정하는 방법은 크게 두 가지가 있다. 
   1. 상대 오차 사용. 
   2. 사용자 임의 오차 사용

흠... 이또한 많은 예시가 있고, 상대오차 사용법에 대한 간단한 코드를 소개할 수 있지만..
솔직히 많이 복잡하고, 크게 의미없다고 생각한다. 
* 내가 의미없다고 생각한 이유 : 상대오차를 사용해 실수형 비교 연산을 진행할 경우, 추가적인 연산이 필요하기 때문에 , 알고리즘 해결 속도가 늦어진다. 
* 추가로 상대오차를 이용해 실수형 비교연산을 한다고 가정해도, 오버플로가 발생하는 것을 무조건 막을 수 있는 것 또한 아니다. 
* 아울러, 임의로 오차를 지정한 경우 또한, 코드가 길어지는 경우나 공동 작업 시에 오차 범위를 계속 기억하고 있는 것 또한 비효율 적이라고 생각한다. 

## 따라서, 이 책에서 명시하는 것 처럼, 가능한 실수형의 연산을 피하는 것이 알고리즘 작성에 있어 가장 현명한 방법인 것같다. 

---